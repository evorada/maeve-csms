// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package api

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/oapi-codegen/runtime"
)

// Defines values for ChangeAvailabilityRequestType.
const (
	Inoperative ChangeAvailabilityRequestType = "Inoperative"
	Operative   ChangeAvailabilityRequestType = "Operative"
)

// Defines values for ChargeStationInstallCertificatesCertificatesStatus.
const (
	ChargeStationInstallCertificatesCertificatesStatusAccepted ChargeStationInstallCertificatesCertificatesStatus = "Accepted"
	ChargeStationInstallCertificatesCertificatesStatusPending  ChargeStationInstallCertificatesCertificatesStatus = "Pending"
	ChargeStationInstallCertificatesCertificatesStatusRejected ChargeStationInstallCertificatesCertificatesStatus = "Rejected"
)

// Defines values for ChargeStationInstallCertificatesCertificatesType.
const (
	CSMS ChargeStationInstallCertificatesCertificatesType = "CSMS"
	MF   ChargeStationInstallCertificatesCertificatesType = "MF"
	MO   ChargeStationInstallCertificatesCertificatesType = "MO"
	V2G  ChargeStationInstallCertificatesCertificatesType = "V2G"
)

// Defines values for ChargeStationTriggerTrigger.
const (
	BootNotification                  ChargeStationTriggerTrigger = "BootNotification"
	DiagnosticsStatusNotification     ChargeStationTriggerTrigger = "DiagnosticsStatusNotification"
	FirmwareStatusNotification        ChargeStationTriggerTrigger = "FirmwareStatusNotification"
	Heartbeat                         ChargeStationTriggerTrigger = "Heartbeat"
	LogStatusNotification             ChargeStationTriggerTrigger = "LogStatusNotification"
	MeterValues                       ChargeStationTriggerTrigger = "MeterValues"
	NotifyMonitoringReport            ChargeStationTriggerTrigger = "NotifyMonitoringReport"
	NotifyReport                      ChargeStationTriggerTrigger = "NotifyReport"
	PublishFirmwareStatusNotification ChargeStationTriggerTrigger = "PublishFirmwareStatusNotification"
	SignChargingStationCertificate    ChargeStationTriggerTrigger = "SignChargingStationCertificate"
	SignCombinedCertificate           ChargeStationTriggerTrigger = "SignCombinedCertificate"
	SignV2GCertificate                ChargeStationTriggerTrigger = "SignV2GCertificate"
	StatusNotification                ChargeStationTriggerTrigger = "StatusNotification"
)

// Defines values for ConnectorFormat.
const (
	CABLE  ConnectorFormat = "CABLE"
	SOCKET ConnectorFormat = "SOCKET"
)

// Defines values for ConnectorPowerType.
const (
	AC1PHASE ConnectorPowerType = "AC_1_PHASE"
	AC3PHASE ConnectorPowerType = "AC_3_PHASE"
	DC       ConnectorPowerType = "DC"
)

// Defines values for ConnectorStandard.
const (
	CHADEMO            ConnectorStandard = "CHADEMO"
	CHAOJI             ConnectorStandard = "CHAOJI"
	DOMESTICA          ConnectorStandard = "DOMESTIC_A"
	DOMESTICB          ConnectorStandard = "DOMESTIC_B"
	DOMESTICC          ConnectorStandard = "DOMESTIC_C"
	DOMESTICD          ConnectorStandard = "DOMESTIC_D"
	DOMESTICE          ConnectorStandard = "DOMESTIC_E"
	DOMESTICF          ConnectorStandard = "DOMESTIC_F"
	DOMESTICG          ConnectorStandard = "DOMESTIC_G"
	DOMESTICH          ConnectorStandard = "DOMESTIC_H"
	DOMESTICI          ConnectorStandard = "DOMESTIC_I"
	DOMESTICJ          ConnectorStandard = "DOMESTIC_J"
	DOMESTICK          ConnectorStandard = "DOMESTIC_K"
	DOMESTICL          ConnectorStandard = "DOMESTIC_L"
	GBTAC              ConnectorStandard = "GBT_AC"
	GBTDC              ConnectorStandard = "GBT_DC"
	IEC603092Single16  ConnectorStandard = "IEC_60309_2_single_16"
	IEC603092Three16   ConnectorStandard = "IEC_60309_2_three_16"
	IEC603092Three32   ConnectorStandard = "IEC_60309_2_three_32"
	IEC603092Three64   ConnectorStandard = "IEC_60309_2_three_64"
	IEC62196T1         ConnectorStandard = "IEC_62196_T1"
	IEC62196T1COMBO    ConnectorStandard = "IEC_62196_T1_COMBO"
	IEC62196T2         ConnectorStandard = "IEC_62196_T2"
	IEC62196T2COMBO    ConnectorStandard = "IEC_62196_T2_COMBO"
	IEC62196T3A        ConnectorStandard = "IEC_62196_T3A"
	IEC62196T3C        ConnectorStandard = "IEC_62196_T3C"
	NEMA1030           ConnectorStandard = "NEMA_10_30"
	NEMA1050           ConnectorStandard = "NEMA_10_50"
	NEMA1430           ConnectorStandard = "NEMA_14_30"
	NEMA1450           ConnectorStandard = "NEMA_14_50"
	NEMA520            ConnectorStandard = "NEMA_5_20"
	NEMA630            ConnectorStandard = "NEMA_6_30"
	NEMA650            ConnectorStandard = "NEMA_6_50"
	PANTOGRAPHBOTTOMUP ConnectorStandard = "PANTOGRAPH_BOTTOM_UP"
	PANTOGRAPHTOPDOWN  ConnectorStandard = "PANTOGRAPH_TOP_DOWN"
	TESLAR             ConnectorStandard = "TESLA_R"
	TESLAS             ConnectorStandard = "TESLA_S"
	UNKNOWN            ConnectorStandard = "UNKNOWN"
)

// Defines values for DataTransferResponseStatus.
const (
	DataTransferResponseStatusAccepted         DataTransferResponseStatus = "Accepted"
	DataTransferResponseStatusRejected         DataTransferResponseStatus = "Rejected"
	DataTransferResponseStatusUnknownMessageId DataTransferResponseStatus = "UnknownMessageId"
	DataTransferResponseStatusUnknownVendorId  DataTransferResponseStatus = "UnknownVendorId"
)

// Defines values for DiagnosticsStatusStatus.
const (
	DiagnosticsStatusStatusIdle         DiagnosticsStatusStatus = "Idle"
	DiagnosticsStatusStatusUploadFailed DiagnosticsStatusStatus = "UploadFailed"
	DiagnosticsStatusStatusUploaded     DiagnosticsStatusStatus = "Uploaded"
	DiagnosticsStatusStatusUploading    DiagnosticsStatusStatus = "Uploading"
)

// Defines values for FirmwareStatusStatus.
const (
	FirmwareStatusStatusDownloadFailed     FirmwareStatusStatus = "DownloadFailed"
	FirmwareStatusStatusDownloaded         FirmwareStatusStatus = "Downloaded"
	FirmwareStatusStatusDownloading        FirmwareStatusStatus = "Downloading"
	FirmwareStatusStatusIdle               FirmwareStatusStatus = "Idle"
	FirmwareStatusStatusInstallationFailed FirmwareStatusStatus = "InstallationFailed"
	FirmwareStatusStatusInstalled          FirmwareStatusStatus = "Installed"
	FirmwareStatusStatusInstalling         FirmwareStatusStatus = "Installing"
)

// Defines values for LocationParkingType.
const (
	ALONGMOTORWAY     LocationParkingType = "ALONG_MOTORWAY"
	ONDRIVEWAY        LocationParkingType = "ON_DRIVEWAY"
	ONSTREET          LocationParkingType = "ON_STREET"
	PARKINGGARAGE     LocationParkingType = "PARKING_GARAGE"
	PARKINGLOT        LocationParkingType = "PARKING_LOT"
	UNDERGROUNDGARAGE LocationParkingType = "UNDERGROUND_GARAGE"
)

// Defines values for LogRequestLogType.
const (
	DiagnosticsLog LogRequestLogType = "DiagnosticsLog"
	SecurityLog    LogRequestLogType = "SecurityLog"
)

// Defines values for LogStatusStatus.
const (
	BadMessage            LogStatusStatus = "BadMessage"
	Idle                  LogStatusStatus = "Idle"
	NotSupportedOperation LogStatusStatus = "NotSupportedOperation"
	PermissionDenied      LogStatusStatus = "PermissionDenied"
	UploadFailure         LogStatusStatus = "UploadFailure"
	Uploaded              LogStatusStatus = "Uploaded"
	Uploading             LogStatusStatus = "Uploading"
)

// Defines values for RegistrationStatus.
const (
	PENDING    RegistrationStatus = "PENDING"
	REGISTERED RegistrationStatus = "REGISTERED"
)

// Defines values for ReservationResponseStatus.
const (
	ReservationResponseStatusAccepted    ReservationResponseStatus = "Accepted"
	ReservationResponseStatusCancelled   ReservationResponseStatus = "Cancelled"
	ReservationResponseStatusExpired     ReservationResponseStatus = "Expired"
	ReservationResponseStatusFaulted     ReservationResponseStatus = "Faulted"
	ReservationResponseStatusOccupied    ReservationResponseStatus = "Occupied"
	ReservationResponseStatusRejected    ReservationResponseStatus = "Rejected"
	ReservationResponseStatusUnavailable ReservationResponseStatus = "Unavailable"
)

// Defines values for TokenCacheMode.
const (
	ALLOWED        TokenCacheMode = "ALLOWED"
	ALLOWEDOFFLINE TokenCacheMode = "ALLOWED_OFFLINE"
	ALWAYS         TokenCacheMode = "ALWAYS"
	NEVER          TokenCacheMode = "NEVER"
)

// Defines values for TokenType.
const (
	ADHOCUSER TokenType = "AD_HOC_USER"
	APPUSER   TokenType = "APP_USER"
	OTHER     TokenType = "OTHER"
	RFID      TokenType = "RFID"
)

// Defines values for ListReservationsParamsStatus.
const (
	ListReservationsParamsStatusActive  ListReservationsParamsStatus = "active"
	ListReservationsParamsStatusAll     ListReservationsParamsStatus = "all"
	ListReservationsParamsStatusExpired ListReservationsParamsStatus = "expired"
)

// Certificate A client certificate
type Certificate struct {
	// Certificate The PEM encoded certificate with newlines replaced by `\n`
	Certificate string `json:"certificate"`
}

// ChangeAvailabilityRequest Request to change charge station or connector availability
type ChangeAvailabilityRequest struct {
	// ConnectorId Connector ID (0 = entire station, >0 = specific connector)
	ConnectorId *int `json:"connectorId,omitempty"`

	// EvseId EVSE ID for OCPP 2.0.1 (optional)
	EvseId *int `json:"evseId,omitempty"`

	// Type Target availability state
	Type ChangeAvailabilityRequestType `json:"type"`
}

// ChangeAvailabilityRequestType Target availability state
type ChangeAvailabilityRequestType string

// ChargeStationAuth Connection details for a charge station
type ChargeStationAuth struct {
	// Base64SHA256Password The base64 encoded, SHA-256 hash of the charge station password
	Base64SHA256Password *string `json:"base64SHA256Password,omitempty"`

	// InvalidUsernameAllowed If set to true then an invalid username will not prevent the charge station connecting
	InvalidUsernameAllowed *bool `json:"invalidUsernameAllowed,omitempty"`

	// SecurityProfile The security profile to use for the charge station: * `0` - unsecured transport with basic auth * `1` - TLS with basic auth * `2` - TLS with client certificate
	SecurityProfile int `json:"securityProfile"`
}

// ChargeStationInstallCertificates The set of certificates to install on the charge station. The certificates will be sent
// to the charge station asynchronously.
type ChargeStationInstallCertificates struct {
	Certificates []struct {
		// Certificate The PEM encoded certificate with newlines replaced by `\n`
		Certificate string `json:"certificate"`

		// Status The status, defaults to Pending
		Status *ChargeStationInstallCertificatesCertificatesStatus `json:"status,omitempty"`
		Type   ChargeStationInstallCertificatesCertificatesType    `json:"type"`
	} `json:"certificates"`
}

// ChargeStationInstallCertificatesCertificatesStatus The status, defaults to Pending
type ChargeStationInstallCertificatesCertificatesStatus string

// ChargeStationInstallCertificatesCertificatesType defines model for ChargeStationInstallCertificates.Certificates.Type.
type ChargeStationInstallCertificatesCertificatesType string

// ChargeStationSettings Settings for a charge station
type ChargeStationSettings map[string]string

// ChargeStationTrigger Trigger a charge station action
type ChargeStationTrigger struct {
	// ConnectorId Optional connector ID. Required for some message types (StatusNotification, MeterValues)
	ConnectorId *int                        `json:"connectorId,omitempty"`
	Trigger     ChargeStationTriggerTrigger `json:"trigger"`
}

// ChargeStationTriggerTrigger defines model for ChargeStationTrigger.Trigger.
type ChargeStationTriggerTrigger string

// Connector defines model for Connector.
type Connector struct {
	Format      ConnectorFormat    `json:"format"`
	Id          string             `json:"id"`
	MaxAmperage int32              `json:"max_amperage"`
	MaxVoltage  int32              `json:"max_voltage"`
	PowerType   ConnectorPowerType `json:"power_type"`
	Standard    ConnectorStandard  `json:"standard"`
}

// ConnectorFormat defines model for Connector.Format.
type ConnectorFormat string

// ConnectorPowerType defines model for Connector.PowerType.
type ConnectorPowerType string

// ConnectorStandard defines model for Connector.Standard.
type ConnectorStandard string

// DataTransferRequest Request to send vendor-specific data to charge station
type DataTransferRequest struct {
	// Data Arbitrary string data (format defined by vendor)
	Data *string `json:"data,omitempty"`

	// MessageId Optional message identifier for the data transfer
	MessageId *string `json:"messageId,omitempty"`

	// VendorId Vendor identifier (vendor-specific)
	VendorId string `json:"vendorId"`
}

// DataTransferResponse Response from data transfer request
type DataTransferResponse struct {
	// Data Response data from the charge station (vendor-specific)
	Data *string `json:"data,omitempty"`

	// Status Status of the data transfer
	Status *DataTransferResponseStatus `json:"status,omitempty"`
}

// DataTransferResponseStatus Status of the data transfer
type DataTransferResponseStatus string

// DiagnosticsRequest Request to upload diagnostics from charge station
type DiagnosticsRequest struct {
	// Location URI where diagnostics should be uploaded
	Location string `json:"location"`

	// Retries Number of retries if upload fails
	Retries *int `json:"retries,omitempty"`

	// RetryInterval Interval in seconds between retry attempts
	RetryInterval *int `json:"retryInterval,omitempty"`

	// StartTime Optional start time for diagnostics collection period
	StartTime *time.Time `json:"startTime,omitempty"`

	// StopTime Optional end time for diagnostics collection period
	StopTime *time.Time `json:"stopTime,omitempty"`
}

// DiagnosticsStatus Current diagnostics upload status
type DiagnosticsStatus struct {
	// FileName Name of the diagnostics file being uploaded
	FileName *string `json:"fileName,omitempty"`

	// LastUpdate Timestamp of the last status update
	LastUpdate *time.Time `json:"lastUpdate,omitempty"`

	// Status Current diagnostics upload status
	Status DiagnosticsStatusStatus `json:"status"`
}

// DiagnosticsStatusStatus Current diagnostics upload status
type DiagnosticsStatusStatus string

// Evse defines model for Evse.
type Evse struct {
	Connectors []Connector `json:"connectors"`
	EvseId     *string     `json:"evse_id"`

	// Uid Uniquely identifies the EVSE within the CPOs platform (and
	// suboperator platforms).
	Uid string `json:"uid"`
}

// FirmwareStatus Current firmware status of a charge station
type FirmwareStatus struct {
	// CurrentVersion Currently installed firmware version
	CurrentVersion *string `json:"currentVersion,omitempty"`

	// LastUpdate Timestamp of the last status update
	LastUpdate *time.Time `json:"lastUpdate,omitempty"`

	// PendingVersion Version being downloaded/installed (if update in progress)
	PendingVersion *string `json:"pendingVersion,omitempty"`

	// Status Current firmware update status
	Status FirmwareStatusStatus `json:"status"`
}

// FirmwareStatusStatus Current firmware update status
type FirmwareStatusStatus string

// FirmwareUpdateRequest Request to update charge station firmware
type FirmwareUpdateRequest struct {
	// Location URI where the firmware can be downloaded (HTTP/HTTPS/FTP)
	Location string `json:"location"`

	// Retries Number of retries if download fails (default: 0)
	Retries *int `json:"retries,omitempty"`

	// RetrieveDate Optional scheduled time to start the firmware download. If not provided, download starts immediately
	RetrieveDate *time.Time `json:"retrieveDate,omitempty"`

	// RetryInterval Interval in seconds between retry attempts (default: 0)
	RetryInterval *int `json:"retryInterval,omitempty"`

	// Signature Base64 encoded signature of the firmware for signed updates
	Signature *string `json:"signature,omitempty"`

	// SigningCertificate PEM encoded certificate used to sign the firmware
	SigningCertificate *string `json:"signingCertificate,omitempty"`
}

// GeoLocation defines model for GeoLocation.
type GeoLocation struct {
	Latitude  string `json:"latitude"`
	Longitude string `json:"longitude"`
}

// Location A charge station location
type Location struct {
	Address     string               `json:"address"`
	City        string               `json:"city"`
	Coordinates GeoLocation          `json:"coordinates"`
	Country     string               `json:"country"`
	CountryCode string               `json:"country_code"`
	Evses       *[]Evse              `json:"evses"`
	Name        *string              `json:"name"`
	ParkingType *LocationParkingType `json:"parking_type"`
	PartyId     string               `json:"party_id"`
	PostalCode  *string              `json:"postal_code"`
}

// LocationParkingType defines model for Location.ParkingType.
type LocationParkingType string

// LogRequest Request to upload logs from charge station (OCPP 2.0.1)
type LogRequest struct {
	Log struct {
		// LatestTimestamp Optional latest timestamp for log entries
		LatestTimestamp *time.Time `json:"latestTimestamp,omitempty"`

		// OldestTimestamp Optional oldest timestamp for log entries
		OldestTimestamp *time.Time `json:"oldestTimestamp,omitempty"`

		// RemoteLocation URI where logs should be uploaded
		RemoteLocation string `json:"remoteLocation"`
	} `json:"log"`

	// LogType Type of log to retrieve
	LogType LogRequestLogType `json:"logType"`

	// RequestId Unique request ID to track this log request
	RequestId int `json:"requestId"`

	// Retries Number of retries if upload fails
	Retries *int `json:"retries,omitempty"`

	// RetryInterval Interval in seconds between retry attempts
	RetryInterval *int `json:"retryInterval,omitempty"`
}

// LogRequestLogType Type of log to retrieve
type LogRequestLogType string

// LogStatus Current log upload status
type LogStatus struct {
	// LastUpdate Timestamp of the last status update
	LastUpdate *time.Time `json:"lastUpdate,omitempty"`

	// RequestId Request ID associated with this status
	RequestId *int `json:"requestId,omitempty"`

	// Status Current log upload status
	Status LogStatusStatus `json:"status"`
}

// LogStatusStatus Current log upload status
type LogStatusStatus string

// MeterValue A set of meter values at a specific timestamp
type MeterValue struct {
	// ConnectorId Connector ID for the reading
	ConnectorId *int `json:"connectorId,omitempty"`

	// EvseId EVSE ID for OCPP 2.0.1
	EvseId *int `json:"evseId,omitempty"`

	// SampledValue Array of sampled values
	SampledValue []MeterValuesSampledValue `json:"sampledValue"`

	// Timestamp Timestamp of the meter reading
	Timestamp time.Time `json:"timestamp"`

	// TransactionId Transaction ID (if part of a transaction)
	TransactionId *string `json:"transactionId,omitempty"`
}

// MeterValuesResponse Paginated list of meter values
type MeterValuesResponse struct {
	// Limit Maximum number of results returned
	Limit int `json:"limit"`

	// MeterValues Array of meter value records
	MeterValues []MeterValue `json:"meterValues"`

	// Offset Number of results skipped
	Offset int `json:"offset"`

	// Total Total number of matching records
	Total int `json:"total"`
}

// MeterValuesSampledValue A single sampled value in a meter reading
type MeterValuesSampledValue struct {
	// Context Reading context (e.g., Sample.Periodic, Transaction.Begin)
	Context *string `json:"context,omitempty"`

	// Format Value format (Raw or SignedData)
	Format *string `json:"format,omitempty"`

	// Location Location of measurement (Cable, EV, Inlet, Outlet, Body)
	Location *string `json:"location,omitempty"`

	// Measurand Type of measurement (e.g., Energy.Active.Import.Register, Power.Active.Import)
	Measurand *string `json:"measurand,omitempty"`

	// Phase Phase measured (L1, L2, L3, N, L1-N, L2-N, L3-N, L1-L2, L2-L3, L3-L1)
	Phase *string `json:"phase,omitempty"`

	// Unit Unit of measurement (Wh, kWh, varh, kvarh, W, kW, VA, kVA, var, kvar, A, V, K, Celsius, Fahrenheit, Percent)
	Unit *string `json:"unit,omitempty"`

	// Value Measured value (numeric as string)
	Value string `json:"value"`
}

// Registration Defines the initial connection details for the OCPI registration process
type Registration struct {
	// Status The status of the registration request. If the request is marked as `REGISTERED` then the token will be allowed to
	// be used to access all endpoints avoiding the need for the OCPI registration process. If the request is marked as
	// `PENDING` then the token will only be allowed to access the `/ocpi/versions`, `/ocpi/2.2` and `/ocpi/2.2/credentials`
	// endpoints.
	Status *RegistrationStatus `json:"status,omitempty"`

	// Token The token to use for communicating with the eMSP (CREDENTIALS_TOKEN_A).
	Token string `json:"token"`

	// Url The URL of the eMSP versions endpoint. If provided the CSMS will act as the sender of the versions request.
	Url *string `json:"url,omitempty"`
}

// RegistrationStatus The status of the registration request. If the request is marked as `REGISTERED` then the token will be allowed to
// be used to access all endpoints avoiding the need for the OCPI registration process. If the request is marked as
// `PENDING` then the token will only be allowed to access the `/ocpi/versions`, `/ocpi/2.2` and `/ocpi/2.2/credentials`
// endpoints.
type RegistrationStatus string

// ReservationList List of reservations
type ReservationList struct {
	Reservations []ReservationResponse `json:"reservations"`
}

// ReservationRequest Request to create a connector reservation
type ReservationRequest struct {
	// ConnectorId The connector ID to reserve
	ConnectorId int32 `json:"connectorId"`

	// ExpiryDate ISO 8601 timestamp when the reservation expires
	ExpiryDate time.Time `json:"expiryDate"`

	// IdTag The identifier for which the charge station has to reserve a connector
	IdTag string `json:"idTag"`

	// ParentIdTag Optional parent idTag
	ParentIdTag *string `json:"parentIdTag,omitempty"`

	// ReservationId Unique identifier for this reservation
	ReservationId int32 `json:"reservationId"`
}

// ReservationResponse Reservation details
type ReservationResponse struct {
	// ConnectorId The connector ID
	ConnectorId int32 `json:"connectorId"`

	// CreatedAt ISO 8601 timestamp when the reservation was created
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// ExpiryDate ISO 8601 timestamp when the reservation expires
	ExpiryDate time.Time `json:"expiryDate"`

	// IdTag The identifier for which the connector is reserved
	IdTag string `json:"idTag"`

	// ParentIdTag Optional parent idTag
	ParentIdTag *string `json:"parentIdTag,omitempty"`

	// ReservationId Unique identifier for this reservation
	ReservationId int32 `json:"reservationId"`

	// Status Current status of the reservation
	Status ReservationResponseStatus `json:"status"`
}

// ReservationResponseStatus Current status of the reservation
type ReservationResponseStatus string

// Status HTTP status
type Status struct {
	// Error The error details
	Error *string `json:"error,omitempty"`

	// Status The status description
	Status string `json:"status"`
}

// Token An authorization token
type Token struct {
	// CacheMode Indicates what type of token caching is allowed
	CacheMode TokenCacheMode `json:"cacheMode"`

	// ContractId The contract ID (eMAID) associated with the token (with optional component separators)
	ContractId string `json:"contractId"`

	// CountryCode The country code of the issuing eMSP
	CountryCode string `json:"countryCode"`

	// GroupId This id groups a couple of tokens to make two or more tokens work as one
	GroupId *string `json:"groupId,omitempty"`

	// Issuer Issuing company, most of the times the name of the company printed on the RFID card, not necessarily the eMSP
	Issuer string `json:"issuer"`

	// LanguageCode The preferred language to use encoded as ISO 639-1 language code
	LanguageCode *string `json:"languageCode,omitempty"`

	// LastUpdated The date the record was last updated (ignored on create/update)
	LastUpdated *time.Time `json:"lastUpdated,omitempty"`

	// PartyId The party id of the issuing eMSP
	PartyId string `json:"partyId"`

	// Type The type of token
	Type TokenType `json:"type"`

	// Uid The unique token id
	Uid string `json:"uid"`

	// Valid Is this token valid
	Valid bool `json:"valid"`

	// VisualNumber The visual/readable number/identification printed on an RFID card
	VisualNumber *string `json:"visualNumber,omitempty"`
}

// TokenCacheMode Indicates what type of token caching is allowed
type TokenCacheMode string

// TokenType The type of token
type TokenType string

// GetChargeStationLogStatusParams defines parameters for GetChargeStationLogStatus.
type GetChargeStationLogStatusParams struct {
	// RequestId Filter by specific request ID
	RequestId *int `form:"requestId,omitempty" json:"requestId,omitempty"`
}

// GetMeterValuesParams defines parameters for GetMeterValues.
type GetMeterValuesParams struct {
	// ConnectorId Filter by connector ID
	ConnectorId *int `form:"connectorId,omitempty" json:"connectorId,omitempty"`

	// TransactionId Filter by transaction ID
	TransactionId *string `form:"transactionId,omitempty" json:"transactionId,omitempty"`

	// StartTime Filter by start time (ISO 8601)
	StartTime *time.Time `form:"startTime,omitempty" json:"startTime,omitempty"`

	// EndTime Filter by end time (ISO 8601)
	EndTime *time.Time `form:"endTime,omitempty" json:"endTime,omitempty"`

	// Limit Maximum number of results to return
	Limit *int `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of results to skip (pagination)
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListReservationsParams defines parameters for ListReservations.
type ListReservationsParams struct {
	// Status Filter by reservation status (default: active)
	Status *ListReservationsParamsStatus `form:"status,omitempty" json:"status,omitempty"`
}

// ListReservationsParamsStatus defines parameters for ListReservations.
type ListReservationsParamsStatus string

// ListTokensParams defines parameters for ListTokens.
type ListTokensParams struct {
	Offset *int `form:"offset,omitempty" json:"offset,omitempty"`
	Limit  *int `form:"limit,omitempty" json:"limit,omitempty"`
}

// UploadCertificateJSONRequestBody defines body for UploadCertificate for application/json ContentType.
type UploadCertificateJSONRequestBody = Certificate

// RegisterChargeStationJSONRequestBody defines body for RegisterChargeStation for application/json ContentType.
type RegisterChargeStationJSONRequestBody = ChargeStationAuth

// ChangeAvailabilityJSONRequestBody defines body for ChangeAvailability for application/json ContentType.
type ChangeAvailabilityJSONRequestBody = ChangeAvailabilityRequest

// InstallChargeStationCertificatesJSONRequestBody defines body for InstallChargeStationCertificates for application/json ContentType.
type InstallChargeStationCertificatesJSONRequestBody = ChargeStationInstallCertificates

// SendDataTransferJSONRequestBody defines body for SendDataTransfer for application/json ContentType.
type SendDataTransferJSONRequestBody = DataTransferRequest

// RequestChargeStationDiagnosticsJSONRequestBody defines body for RequestChargeStationDiagnostics for application/json ContentType.
type RequestChargeStationDiagnosticsJSONRequestBody = DiagnosticsRequest

// UpdateChargeStationFirmwareJSONRequestBody defines body for UpdateChargeStationFirmware for application/json ContentType.
type UpdateChargeStationFirmwareJSONRequestBody = FirmwareUpdateRequest

// RequestChargeStationLogsJSONRequestBody defines body for RequestChargeStationLogs for application/json ContentType.
type RequestChargeStationLogsJSONRequestBody = LogRequest

// ReconfigureChargeStationJSONRequestBody defines body for ReconfigureChargeStation for application/json ContentType.
type ReconfigureChargeStationJSONRequestBody = ChargeStationSettings

// CreateReservationJSONRequestBody defines body for CreateReservation for application/json ContentType.
type CreateReservationJSONRequestBody = ReservationRequest

// TriggerChargeStationJSONRequestBody defines body for TriggerChargeStation for application/json ContentType.
type TriggerChargeStationJSONRequestBody = ChargeStationTrigger

// RegisterLocationJSONRequestBody defines body for RegisterLocation for application/json ContentType.
type RegisterLocationJSONRequestBody = Location

// RegisterPartyJSONRequestBody defines body for RegisterParty for application/json ContentType.
type RegisterPartyJSONRequestBody = Registration

// SetTokenJSONRequestBody defines body for SetToken for application/json ContentType.
type SetTokenJSONRequestBody = Token

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Upload a certificate
	// (POST /certificate)
	UploadCertificate(w http.ResponseWriter, r *http.Request)
	// Delete a certificate
	// (DELETE /certificate/{certificateHash})
	DeleteCertificate(w http.ResponseWriter, r *http.Request, certificateHash string)
	// Lookup a certificate
	// (GET /certificate/{certificateHash})
	LookupCertificate(w http.ResponseWriter, r *http.Request, certificateHash string)
	// Register a new charge station
	// (POST /cs/{csId})
	RegisterChargeStation(w http.ResponseWriter, r *http.Request, csId string)
	// Returns the authentication details
	// (GET /cs/{csId}/auth)
	LookupChargeStationAuth(w http.ResponseWriter, r *http.Request, csId string)
	// Change charge station availability
	// (POST /cs/{csId}/availability)
	ChangeAvailability(w http.ResponseWriter, r *http.Request, csId string)
	// Clear authorization cache on charge station
	// (POST /cs/{csId}/cache/clear)
	ClearAuthorizationCache(w http.ResponseWriter, r *http.Request, csId string)
	// Install certificates on the charge station
	// (POST /cs/{csId}/certificates)
	InstallChargeStationCertificates(w http.ResponseWriter, r *http.Request, csId string)
	// Send data transfer to charge station
	// (POST /cs/{csId}/data-transfer)
	SendDataTransfer(w http.ResponseWriter, r *http.Request, csId string)
	// Request diagnostics from charge station
	// (POST /cs/{csId}/diagnostics)
	RequestChargeStationDiagnostics(w http.ResponseWriter, r *http.Request, csId string)
	// Get diagnostics upload status
	// (GET /cs/{csId}/diagnostics/status)
	GetChargeStationDiagnosticsStatus(w http.ResponseWriter, r *http.Request, csId string)
	// Get firmware update status
	// (GET /cs/{csId}/firmware/status)
	GetChargeStationFirmwareStatus(w http.ResponseWriter, r *http.Request, csId string)
	// Trigger firmware update on charge station
	// (POST /cs/{csId}/firmware/update)
	UpdateChargeStationFirmware(w http.ResponseWriter, r *http.Request, csId string)
	// Request log upload from charge station
	// (POST /cs/{csId}/logs)
	RequestChargeStationLogs(w http.ResponseWriter, r *http.Request, csId string)
	// Get log upload status
	// (GET /cs/{csId}/logs/status)
	GetChargeStationLogStatus(w http.ResponseWriter, r *http.Request, csId string, params GetChargeStationLogStatusParams)
	// Get meter values from charge station
	// (GET /cs/{csId}/meter-values)
	GetMeterValues(w http.ResponseWriter, r *http.Request, csId string, params GetMeterValuesParams)
	// Reconfigure the charge station
	// (POST /cs/{csId}/reconfigure)
	ReconfigureChargeStation(w http.ResponseWriter, r *http.Request, csId string)
	// Create a connector reservation
	// (POST /cs/{csId}/reservation)
	CreateReservation(w http.ResponseWriter, r *http.Request, csId string)
	// Cancel a reservation
	// (DELETE /cs/{csId}/reservation/{reservationId})
	CancelReservation(w http.ResponseWriter, r *http.Request, csId string, reservationId int32)
	// List reservations
	// (GET /cs/{csId}/reservations)
	ListReservations(w http.ResponseWriter, r *http.Request, csId string, params ListReservationsParams)

	// (POST /cs/{csId}/trigger)
	TriggerChargeStation(w http.ResponseWriter, r *http.Request, csId string)
	// Registers a location with the CSMS
	// (POST /location/{locationId})
	RegisterLocation(w http.ResponseWriter, r *http.Request, locationId string)
	// Registers an OCPI party with the CSMS
	// (POST /register)
	RegisterParty(w http.ResponseWriter, r *http.Request)
	// List authorization tokens
	// (GET /token)
	ListTokens(w http.ResponseWriter, r *http.Request, params ListTokensParams)
	// Create/update an authorization token
	// (POST /token)
	SetToken(w http.ResponseWriter, r *http.Request)
	// Lookup an authorization token
	// (GET /token/{tokenUid})
	LookupToken(w http.ResponseWriter, r *http.Request, tokenUid string)
}

// Unimplemented server implementation that returns http.StatusNotImplemented for each endpoint.

type Unimplemented struct{}

// Upload a certificate
// (POST /certificate)
func (_ Unimplemented) UploadCertificate(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Delete a certificate
// (DELETE /certificate/{certificateHash})
func (_ Unimplemented) DeleteCertificate(w http.ResponseWriter, r *http.Request, certificateHash string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Lookup a certificate
// (GET /certificate/{certificateHash})
func (_ Unimplemented) LookupCertificate(w http.ResponseWriter, r *http.Request, certificateHash string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Register a new charge station
// (POST /cs/{csId})
func (_ Unimplemented) RegisterChargeStation(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Returns the authentication details
// (GET /cs/{csId}/auth)
func (_ Unimplemented) LookupChargeStationAuth(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Change charge station availability
// (POST /cs/{csId}/availability)
func (_ Unimplemented) ChangeAvailability(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Clear authorization cache on charge station
// (POST /cs/{csId}/cache/clear)
func (_ Unimplemented) ClearAuthorizationCache(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Install certificates on the charge station
// (POST /cs/{csId}/certificates)
func (_ Unimplemented) InstallChargeStationCertificates(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Send data transfer to charge station
// (POST /cs/{csId}/data-transfer)
func (_ Unimplemented) SendDataTransfer(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request diagnostics from charge station
// (POST /cs/{csId}/diagnostics)
func (_ Unimplemented) RequestChargeStationDiagnostics(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get diagnostics upload status
// (GET /cs/{csId}/diagnostics/status)
func (_ Unimplemented) GetChargeStationDiagnosticsStatus(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get firmware update status
// (GET /cs/{csId}/firmware/status)
func (_ Unimplemented) GetChargeStationFirmwareStatus(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Trigger firmware update on charge station
// (POST /cs/{csId}/firmware/update)
func (_ Unimplemented) UpdateChargeStationFirmware(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Request log upload from charge station
// (POST /cs/{csId}/logs)
func (_ Unimplemented) RequestChargeStationLogs(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get log upload status
// (GET /cs/{csId}/logs/status)
func (_ Unimplemented) GetChargeStationLogStatus(w http.ResponseWriter, r *http.Request, csId string, params GetChargeStationLogStatusParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Get meter values from charge station
// (GET /cs/{csId}/meter-values)
func (_ Unimplemented) GetMeterValues(w http.ResponseWriter, r *http.Request, csId string, params GetMeterValuesParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Reconfigure the charge station
// (POST /cs/{csId}/reconfigure)
func (_ Unimplemented) ReconfigureChargeStation(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create a connector reservation
// (POST /cs/{csId}/reservation)
func (_ Unimplemented) CreateReservation(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Cancel a reservation
// (DELETE /cs/{csId}/reservation/{reservationId})
func (_ Unimplemented) CancelReservation(w http.ResponseWriter, r *http.Request, csId string, reservationId int32) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List reservations
// (GET /cs/{csId}/reservations)
func (_ Unimplemented) ListReservations(w http.ResponseWriter, r *http.Request, csId string, params ListReservationsParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// (POST /cs/{csId}/trigger)
func (_ Unimplemented) TriggerChargeStation(w http.ResponseWriter, r *http.Request, csId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Registers a location with the CSMS
// (POST /location/{locationId})
func (_ Unimplemented) RegisterLocation(w http.ResponseWriter, r *http.Request, locationId string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Registers an OCPI party with the CSMS
// (POST /register)
func (_ Unimplemented) RegisterParty(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// List authorization tokens
// (GET /token)
func (_ Unimplemented) ListTokens(w http.ResponseWriter, r *http.Request, params ListTokensParams) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Create/update an authorization token
// (POST /token)
func (_ Unimplemented) SetToken(w http.ResponseWriter, r *http.Request) {
	w.WriteHeader(http.StatusNotImplemented)
}

// Lookup an authorization token
// (GET /token/{tokenUid})
func (_ Unimplemented) LookupToken(w http.ResponseWriter, r *http.Request, tokenUid string) {
	w.WriteHeader(http.StatusNotImplemented)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
	ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.Handler) http.Handler

// UploadCertificate operation middleware
func (siw *ServerInterfaceWrapper) UploadCertificate(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UploadCertificate(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// DeleteCertificate operation middleware
func (siw *ServerInterfaceWrapper) DeleteCertificate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "certificateHash" -------------
	var certificateHash string

	err = runtime.BindStyledParameterWithOptions("simple", "certificateHash", chi.URLParam(r, "certificateHash"), &certificateHash, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "certificateHash", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteCertificate(w, r, certificateHash)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LookupCertificate operation middleware
func (siw *ServerInterfaceWrapper) LookupCertificate(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "certificateHash" -------------
	var certificateHash string

	err = runtime.BindStyledParameterWithOptions("simple", "certificateHash", chi.URLParam(r, "certificateHash"), &certificateHash, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "certificateHash", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LookupCertificate(w, r, certificateHash)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterChargeStation operation middleware
func (siw *ServerInterfaceWrapper) RegisterChargeStation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterChargeStation(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LookupChargeStationAuth operation middleware
func (siw *ServerInterfaceWrapper) LookupChargeStationAuth(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LookupChargeStationAuth(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ChangeAvailability operation middleware
func (siw *ServerInterfaceWrapper) ChangeAvailability(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ChangeAvailability(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ClearAuthorizationCache operation middleware
func (siw *ServerInterfaceWrapper) ClearAuthorizationCache(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ClearAuthorizationCache(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// InstallChargeStationCertificates operation middleware
func (siw *ServerInterfaceWrapper) InstallChargeStationCertificates(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.InstallChargeStationCertificates(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SendDataTransfer operation middleware
func (siw *ServerInterfaceWrapper) SendDataTransfer(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SendDataTransfer(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestChargeStationDiagnostics operation middleware
func (siw *ServerInterfaceWrapper) RequestChargeStationDiagnostics(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestChargeStationDiagnostics(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChargeStationDiagnosticsStatus operation middleware
func (siw *ServerInterfaceWrapper) GetChargeStationDiagnosticsStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChargeStationDiagnosticsStatus(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChargeStationFirmwareStatus operation middleware
func (siw *ServerInterfaceWrapper) GetChargeStationFirmwareStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChargeStationFirmwareStatus(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// UpdateChargeStationFirmware operation middleware
func (siw *ServerInterfaceWrapper) UpdateChargeStationFirmware(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.UpdateChargeStationFirmware(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RequestChargeStationLogs operation middleware
func (siw *ServerInterfaceWrapper) RequestChargeStationLogs(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RequestChargeStationLogs(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetChargeStationLogStatus operation middleware
func (siw *ServerInterfaceWrapper) GetChargeStationLogStatus(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetChargeStationLogStatusParams

	// ------------- Optional query parameter "requestId" -------------

	err = runtime.BindQueryParameter("form", true, false, "requestId", r.URL.Query(), &params.RequestId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetChargeStationLogStatus(w, r, csId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// GetMeterValues operation middleware
func (siw *ServerInterfaceWrapper) GetMeterValues(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params GetMeterValuesParams

	// ------------- Optional query parameter "connectorId" -------------

	err = runtime.BindQueryParameter("form", true, false, "connectorId", r.URL.Query(), &params.ConnectorId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "connectorId", Err: err})
		return
	}

	// ------------- Optional query parameter "transactionId" -------------

	err = runtime.BindQueryParameter("form", true, false, "transactionId", r.URL.Query(), &params.TransactionId)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "transactionId", Err: err})
		return
	}

	// ------------- Optional query parameter "startTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "startTime", r.URL.Query(), &params.StartTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startTime", Err: err})
		return
	}

	// ------------- Optional query parameter "endTime" -------------

	err = runtime.BindQueryParameter("form", true, false, "endTime", r.URL.Query(), &params.EndTime)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endTime", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.GetMeterValues(w, r, csId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ReconfigureChargeStation operation middleware
func (siw *ServerInterfaceWrapper) ReconfigureChargeStation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ReconfigureChargeStation(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CreateReservation operation middleware
func (siw *ServerInterfaceWrapper) CreateReservation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CreateReservation(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// CancelReservation operation middleware
func (siw *ServerInterfaceWrapper) CancelReservation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	// ------------- Path parameter "reservationId" -------------
	var reservationId int32

	err = runtime.BindStyledParameterWithOptions("simple", "reservationId", chi.URLParam(r, "reservationId"), &reservationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "reservationId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.CancelReservation(w, r, csId, reservationId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListReservations operation middleware
func (siw *ServerInterfaceWrapper) ListReservations(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	// Parameter object where we will unmarshal all parameters from the context
	var params ListReservationsParams

	// ------------- Optional query parameter "status" -------------

	err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListReservations(w, r, csId, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// TriggerChargeStation operation middleware
func (siw *ServerInterfaceWrapper) TriggerChargeStation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "csId" -------------
	var csId string

	err = runtime.BindStyledParameterWithOptions("simple", "csId", chi.URLParam(r, "csId"), &csId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "csId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.TriggerChargeStation(w, r, csId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterLocation operation middleware
func (siw *ServerInterfaceWrapper) RegisterLocation(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "locationId" -------------
	var locationId string

	err = runtime.BindStyledParameterWithOptions("simple", "locationId", chi.URLParam(r, "locationId"), &locationId, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: false})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "locationId", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterLocation(w, r, locationId)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// RegisterParty operation middleware
func (siw *ServerInterfaceWrapper) RegisterParty(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.RegisterParty(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// ListTokens operation middleware
func (siw *ServerInterfaceWrapper) ListTokens(w http.ResponseWriter, r *http.Request) {

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListTokensParams

	// ------------- Optional query parameter "offset" -------------

	err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
		return
	}

	// ------------- Optional query parameter "limit" -------------

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListTokens(w, r, params)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// SetToken operation middleware
func (siw *ServerInterfaceWrapper) SetToken(w http.ResponseWriter, r *http.Request) {

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.SetToken(w, r)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

// LookupToken operation middleware
func (siw *ServerInterfaceWrapper) LookupToken(w http.ResponseWriter, r *http.Request) {

	var err error

	// ------------- Path parameter "tokenUid" -------------
	var tokenUid string

	err = runtime.BindStyledParameterWithOptions("simple", "tokenUid", chi.URLParam(r, "tokenUid"), &tokenUid, runtime.BindStyledParameterOptions{ParamLocation: runtime.ParamLocationPath, Explode: false, Required: true})
	if err != nil {
		siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "tokenUid", Err: err})
		return
	}

	handler := http.Handler(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.LookupToken(w, r, tokenUid)
	}))

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler.ServeHTTP(w, r)
}

type UnescapedCookieParamError struct {
	ParamName string
	Err       error
}

func (e *UnescapedCookieParamError) Error() string {
	return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
	return e.Err
}

type UnmarshalingParamError struct {
	ParamName string
	Err       error
}

func (e *UnmarshalingParamError) Error() string {
	return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
	return e.Err
}

type RequiredParamError struct {
	ParamName string
}

func (e *RequiredParamError) Error() string {
	return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
	ParamName string
	Err       error
}

func (e *RequiredHeaderError) Error() string {
	return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
	return e.Err
}

type InvalidParamFormatError struct {
	ParamName string
	Err       error
}

func (e *InvalidParamFormatError) Error() string {
	return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
	return e.Err
}

type TooManyValuesForParamError struct {
	ParamName string
	Count     int
}

func (e *TooManyValuesForParamError) Error() string {
	return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL          string
	BaseRouter       chi.Router
	Middlewares      []MiddlewareFunc
	ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	if options.ErrorHandlerFunc == nil {
		options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
			http.Error(w, err.Error(), http.StatusBadRequest)
		}
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
		ErrorHandlerFunc:   options.ErrorHandlerFunc,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/certificate", wrapper.UploadCertificate)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/certificate/{certificateHash}", wrapper.DeleteCertificate)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/certificate/{certificateHash}", wrapper.LookupCertificate)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}", wrapper.RegisterChargeStation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/auth", wrapper.LookupChargeStationAuth)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/availability", wrapper.ChangeAvailability)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/cache/clear", wrapper.ClearAuthorizationCache)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/certificates", wrapper.InstallChargeStationCertificates)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/data-transfer", wrapper.SendDataTransfer)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/diagnostics", wrapper.RequestChargeStationDiagnostics)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/diagnostics/status", wrapper.GetChargeStationDiagnosticsStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/firmware/status", wrapper.GetChargeStationFirmwareStatus)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/firmware/update", wrapper.UpdateChargeStationFirmware)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/logs", wrapper.RequestChargeStationLogs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/logs/status", wrapper.GetChargeStationLogStatus)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/meter-values", wrapper.GetMeterValues)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/reconfigure", wrapper.ReconfigureChargeStation)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/reservation", wrapper.CreateReservation)
	})
	r.Group(func(r chi.Router) {
		r.Delete(options.BaseURL+"/cs/{csId}/reservation/{reservationId}", wrapper.CancelReservation)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/cs/{csId}/reservations", wrapper.ListReservations)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/cs/{csId}/trigger", wrapper.TriggerChargeStation)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/location/{locationId}", wrapper.RegisterLocation)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/register", wrapper.RegisterParty)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/token", wrapper.ListTokens)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/token", wrapper.SetToken)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/token/{tokenUid}", wrapper.LookupToken)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"kAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
