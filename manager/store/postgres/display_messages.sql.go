// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: display_messages.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CreateOrUpdateDisplayMessage = `-- name: CreateOrUpdateDisplayMessage :exec
INSERT INTO display_messages (
    charge_station_id, message_id, priority, state, start_date_time, end_date_time,
    transaction_id, content, language, format, created_at, updated_at
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12)
ON CONFLICT (charge_station_id, message_id)
DO UPDATE SET
    priority = EXCLUDED.priority,
    state = EXCLUDED.state,
    start_date_time = EXCLUDED.start_date_time,
    end_date_time = EXCLUDED.end_date_time,
    transaction_id = EXCLUDED.transaction_id,
    content = EXCLUDED.content,
    language = EXCLUDED.language,
    format = EXCLUDED.format,
    updated_at = EXCLUDED.updated_at
`

type CreateOrUpdateDisplayMessageParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	MessageID       int32              `db:"message_id" json:"message_id"`
	Priority        string             `db:"priority" json:"priority"`
	State           pgtype.Text        `db:"state" json:"state"`
	StartDateTime   pgtype.Timestamptz `db:"start_date_time" json:"start_date_time"`
	EndDateTime     pgtype.Timestamptz `db:"end_date_time" json:"end_date_time"`
	TransactionID   pgtype.Text        `db:"transaction_id" json:"transaction_id"`
	Content         string             `db:"content" json:"content"`
	Language        pgtype.Text        `db:"language" json:"language"`
	Format          string             `db:"format" json:"format"`
	CreatedAt       pgtype.Timestamptz `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) CreateOrUpdateDisplayMessage(ctx context.Context, arg CreateOrUpdateDisplayMessageParams) error {
	_, err := q.db.Exec(ctx, CreateOrUpdateDisplayMessage,
		arg.ChargeStationID,
		arg.MessageID,
		arg.Priority,
		arg.State,
		arg.StartDateTime,
		arg.EndDateTime,
		arg.TransactionID,
		arg.Content,
		arg.Language,
		arg.Format,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const DeleteAllDisplayMessages = `-- name: DeleteAllDisplayMessages :exec
DELETE FROM display_messages
WHERE charge_station_id = $1
`

func (q *Queries) DeleteAllDisplayMessages(ctx context.Context, chargeStationID string) error {
	_, err := q.db.Exec(ctx, DeleteAllDisplayMessages, chargeStationID)
	return err
}

const DeleteDisplayMessage = `-- name: DeleteDisplayMessage :exec
DELETE FROM display_messages
WHERE charge_station_id = $1 AND message_id = $2
`

type DeleteDisplayMessageParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	MessageID       int32  `db:"message_id" json:"message_id"`
}

func (q *Queries) DeleteDisplayMessage(ctx context.Context, arg DeleteDisplayMessageParams) error {
	_, err := q.db.Exec(ctx, DeleteDisplayMessage, arg.ChargeStationID, arg.MessageID)
	return err
}

const GetDisplayMessage = `-- name: GetDisplayMessage :one
SELECT charge_station_id, message_id, priority, state, start_date_time, end_date_time, transaction_id, content, language, format, created_at, updated_at FROM display_messages
WHERE charge_station_id = $1 AND message_id = $2
`

type GetDisplayMessageParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	MessageID       int32  `db:"message_id" json:"message_id"`
}

func (q *Queries) GetDisplayMessage(ctx context.Context, arg GetDisplayMessageParams) (DisplayMessage, error) {
	row := q.db.QueryRow(ctx, GetDisplayMessage, arg.ChargeStationID, arg.MessageID)
	var i DisplayMessage
	err := row.Scan(
		&i.ChargeStationID,
		&i.MessageID,
		&i.Priority,
		&i.State,
		&i.StartDateTime,
		&i.EndDateTime,
		&i.TransactionID,
		&i.Content,
		&i.Language,
		&i.Format,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const ListDisplayMessages = `-- name: ListDisplayMessages :many
SELECT charge_station_id, message_id, priority, state, start_date_time, end_date_time, transaction_id, content, language, format, created_at, updated_at FROM display_messages
WHERE charge_station_id = $1
ORDER BY message_id ASC
`

func (q *Queries) ListDisplayMessages(ctx context.Context, chargeStationID string) ([]DisplayMessage, error) {
	rows, err := q.db.Query(ctx, ListDisplayMessages, chargeStationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DisplayMessage{}
	for rows.Next() {
		var i DisplayMessage
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.MessageID,
			&i.Priority,
			&i.State,
			&i.StartDateTime,
			&i.EndDateTime,
			&i.TransactionID,
			&i.Content,
			&i.Language,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDisplayMessagesByPriority = `-- name: ListDisplayMessagesByPriority :many
SELECT charge_station_id, message_id, priority, state, start_date_time, end_date_time, transaction_id, content, language, format, created_at, updated_at FROM display_messages
WHERE charge_station_id = $1 AND priority = $2
ORDER BY message_id ASC
`

type ListDisplayMessagesByPriorityParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Priority        string `db:"priority" json:"priority"`
}

func (q *Queries) ListDisplayMessagesByPriority(ctx context.Context, arg ListDisplayMessagesByPriorityParams) ([]DisplayMessage, error) {
	rows, err := q.db.Query(ctx, ListDisplayMessagesByPriority, arg.ChargeStationID, arg.Priority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DisplayMessage{}
	for rows.Next() {
		var i DisplayMessage
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.MessageID,
			&i.Priority,
			&i.State,
			&i.StartDateTime,
			&i.EndDateTime,
			&i.TransactionID,
			&i.Content,
			&i.Language,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDisplayMessagesByState = `-- name: ListDisplayMessagesByState :many
SELECT charge_station_id, message_id, priority, state, start_date_time, end_date_time, transaction_id, content, language, format, created_at, updated_at FROM display_messages
WHERE charge_station_id = $1 AND state = $2
ORDER BY message_id ASC
`

type ListDisplayMessagesByStateParams struct {
	ChargeStationID string      `db:"charge_station_id" json:"charge_station_id"`
	State           pgtype.Text `db:"state" json:"state"`
}

func (q *Queries) ListDisplayMessagesByState(ctx context.Context, arg ListDisplayMessagesByStateParams) ([]DisplayMessage, error) {
	rows, err := q.db.Query(ctx, ListDisplayMessagesByState, arg.ChargeStationID, arg.State)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DisplayMessage{}
	for rows.Next() {
		var i DisplayMessage
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.MessageID,
			&i.Priority,
			&i.State,
			&i.StartDateTime,
			&i.EndDateTime,
			&i.TransactionID,
			&i.Content,
			&i.Language,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDisplayMessagesByStateAndPriority = `-- name: ListDisplayMessagesByStateAndPriority :many
SELECT charge_station_id, message_id, priority, state, start_date_time, end_date_time, transaction_id, content, language, format, created_at, updated_at FROM display_messages
WHERE charge_station_id = $1 AND state = $2 AND priority = $3
ORDER BY message_id ASC
`

type ListDisplayMessagesByStateAndPriorityParams struct {
	ChargeStationID string      `db:"charge_station_id" json:"charge_station_id"`
	State           pgtype.Text `db:"state" json:"state"`
	Priority        string      `db:"priority" json:"priority"`
}

func (q *Queries) ListDisplayMessagesByStateAndPriority(ctx context.Context, arg ListDisplayMessagesByStateAndPriorityParams) ([]DisplayMessage, error) {
	rows, err := q.db.Query(ctx, ListDisplayMessagesByStateAndPriority, arg.ChargeStationID, arg.State, arg.Priority)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DisplayMessage{}
	for rows.Next() {
		var i DisplayMessage
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.MessageID,
			&i.Priority,
			&i.State,
			&i.StartDateTime,
			&i.EndDateTime,
			&i.TransactionID,
			&i.Content,
			&i.Language,
			&i.Format,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
