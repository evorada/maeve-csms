// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: status.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const GetChargeStationStatus = `-- name: GetChargeStationStatus :one
SELECT
    charge_station_id,
    connected,
    last_heartbeat,
    firmware_version,
    model,
    vendor,
    serial_number,
    updated_at
FROM charge_station_status
WHERE charge_station_id = $1
`

func (q *Queries) GetChargeStationStatus(ctx context.Context, chargeStationID string) (ChargeStationStatus, error) {
	row := q.db.QueryRow(ctx, GetChargeStationStatus, chargeStationID)
	var i ChargeStationStatus
	err := row.Scan(
		&i.ChargeStationID,
		&i.Connected,
		&i.LastHeartbeat,
		&i.FirmwareVersion,
		&i.Model,
		&i.Vendor,
		&i.SerialNumber,
		&i.UpdatedAt,
	)
	return i, err
}

const GetConnectorStatus = `-- name: GetConnectorStatus :one
SELECT
    charge_station_id,
    connector_id,
    status,
    error_code,
    info,
    timestamp,
    vendor_error_code,
    vendor_id,
    current_transaction_id,
    updated_at
FROM connector_status
WHERE charge_station_id = $1 AND connector_id = $2
`

type GetConnectorStatusParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	ConnectorID     int32  `db:"connector_id" json:"connector_id"`
}

func (q *Queries) GetConnectorStatus(ctx context.Context, arg GetConnectorStatusParams) (ConnectorStatus, error) {
	row := q.db.QueryRow(ctx, GetConnectorStatus, arg.ChargeStationID, arg.ConnectorID)
	var i ConnectorStatus
	err := row.Scan(
		&i.ChargeStationID,
		&i.ConnectorID,
		&i.Status,
		&i.ErrorCode,
		&i.Info,
		&i.Timestamp,
		&i.VendorErrorCode,
		&i.VendorID,
		&i.CurrentTransactionID,
		&i.UpdatedAt,
	)
	return i, err
}

const ListConnectorStatuses = `-- name: ListConnectorStatuses :many
SELECT
    charge_station_id,
    connector_id,
    status,
    error_code,
    info,
    timestamp,
    vendor_error_code,
    vendor_id,
    current_transaction_id,
    updated_at
FROM connector_status
WHERE charge_station_id = $1
ORDER BY connector_id
`

func (q *Queries) ListConnectorStatuses(ctx context.Context, chargeStationID string) ([]ConnectorStatus, error) {
	rows, err := q.db.Query(ctx, ListConnectorStatuses, chargeStationID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ConnectorStatus{}
	for rows.Next() {
		var i ConnectorStatus
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.ConnectorID,
			&i.Status,
			&i.ErrorCode,
			&i.Info,
			&i.Timestamp,
			&i.VendorErrorCode,
			&i.VendorID,
			&i.CurrentTransactionID,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateHeartbeat = `-- name: UpdateHeartbeat :exec
INSERT INTO charge_station_status (charge_station_id, connected, last_heartbeat, updated_at)
VALUES ($1, true, $2, NOW())
ON CONFLICT (charge_station_id) DO UPDATE SET
    connected = true,
    last_heartbeat = EXCLUDED.last_heartbeat,
    updated_at = NOW()
`

type UpdateHeartbeatParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	LastHeartbeat   pgtype.Timestamptz `db:"last_heartbeat" json:"last_heartbeat"`
}

func (q *Queries) UpdateHeartbeat(ctx context.Context, arg UpdateHeartbeatParams) error {
	_, err := q.db.Exec(ctx, UpdateHeartbeat, arg.ChargeStationID, arg.LastHeartbeat)
	return err
}

const UpsertChargeStationStatus = `-- name: UpsertChargeStationStatus :exec
INSERT INTO charge_station_status (
    charge_station_id,
    connected,
    last_heartbeat,
    firmware_version,
    model,
    vendor,
    serial_number,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (charge_station_id) DO UPDATE SET
    connected = EXCLUDED.connected,
    last_heartbeat = EXCLUDED.last_heartbeat,
    firmware_version = COALESCE(EXCLUDED.firmware_version, charge_station_status.firmware_version),
    model = COALESCE(EXCLUDED.model, charge_station_status.model),
    vendor = COALESCE(EXCLUDED.vendor, charge_station_status.vendor),
    serial_number = COALESCE(EXCLUDED.serial_number, charge_station_status.serial_number),
    updated_at = EXCLUDED.updated_at
`

type UpsertChargeStationStatusParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	Connected       bool               `db:"connected" json:"connected"`
	LastHeartbeat   pgtype.Timestamptz `db:"last_heartbeat" json:"last_heartbeat"`
	FirmwareVersion pgtype.Text        `db:"firmware_version" json:"firmware_version"`
	Model           pgtype.Text        `db:"model" json:"model"`
	Vendor          pgtype.Text        `db:"vendor" json:"vendor"`
	SerialNumber    pgtype.Text        `db:"serial_number" json:"serial_number"`
	UpdatedAt       pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpsertChargeStationStatus(ctx context.Context, arg UpsertChargeStationStatusParams) error {
	_, err := q.db.Exec(ctx, UpsertChargeStationStatus,
		arg.ChargeStationID,
		arg.Connected,
		arg.LastHeartbeat,
		arg.FirmwareVersion,
		arg.Model,
		arg.Vendor,
		arg.SerialNumber,
		arg.UpdatedAt,
	)
	return err
}

const UpsertConnectorStatus = `-- name: UpsertConnectorStatus :exec
INSERT INTO connector_status (
    charge_station_id,
    connector_id,
    status,
    error_code,
    info,
    timestamp,
    vendor_error_code,
    vendor_id,
    current_transaction_id,
    updated_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (charge_station_id, connector_id) DO UPDATE SET
    status = EXCLUDED.status,
    error_code = EXCLUDED.error_code,
    info = EXCLUDED.info,
    timestamp = EXCLUDED.timestamp,
    vendor_error_code = EXCLUDED.vendor_error_code,
    vendor_id = EXCLUDED.vendor_id,
    current_transaction_id = EXCLUDED.current_transaction_id,
    updated_at = EXCLUDED.updated_at
`

type UpsertConnectorStatusParams struct {
	ChargeStationID      string             `db:"charge_station_id" json:"charge_station_id"`
	ConnectorID          int32              `db:"connector_id" json:"connector_id"`
	Status               string             `db:"status" json:"status"`
	ErrorCode            string             `db:"error_code" json:"error_code"`
	Info                 pgtype.Text        `db:"info" json:"info"`
	Timestamp            pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	VendorErrorCode      pgtype.Text        `db:"vendor_error_code" json:"vendor_error_code"`
	VendorID             pgtype.Text        `db:"vendor_id" json:"vendor_id"`
	CurrentTransactionID pgtype.Text        `db:"current_transaction_id" json:"current_transaction_id"`
	UpdatedAt            pgtype.Timestamptz `db:"updated_at" json:"updated_at"`
}

func (q *Queries) UpsertConnectorStatus(ctx context.Context, arg UpsertConnectorStatusParams) error {
	_, err := q.db.Exec(ctx, UpsertConnectorStatus,
		arg.ChargeStationID,
		arg.ConnectorID,
		arg.Status,
		arg.ErrorCode,
		arg.Info,
		arg.Timestamp,
		arg.VendorErrorCode,
		arg.VendorID,
		arg.CurrentTransactionID,
		arg.UpdatedAt,
	)
	return err
}
