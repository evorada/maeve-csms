// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: transactions.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const AddMeterValues = `-- name: AddMeterValues :exec
INSERT INTO transaction_meter_values (transaction_id, timestamp, sampled_values)
VALUES ($1, $2, $3)
`

type AddMeterValuesParams struct {
	TransactionID string           `db:"transaction_id" json:"transaction_id"`
	Timestamp     pgtype.Timestamp `db:"timestamp" json:"timestamp"`
	SampledValues []byte           `db:"sampled_values" json:"sampled_values"`
}

func (q *Queries) AddMeterValues(ctx context.Context, arg AddMeterValuesParams) error {
	_, err := q.db.Exec(ctx, AddMeterValues, arg.TransactionID, arg.Timestamp, arg.SampledValues)
	return err
}

const CreateTransaction = `-- name: CreateTransaction :one
INSERT INTO transactions (
    id, charge_station_id, token_uid, token_type,
    meter_start, start_timestamp, offline
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, charge_station_id, token_uid, token_type, meter_start, meter_stop, start_timestamp, stop_timestamp, stopped_reason, updated_seq_no, offline, created_at, updated_at, last_cost
`

type CreateTransactionParams struct {
	ID              string           `db:"id" json:"id"`
	ChargeStationID string           `db:"charge_station_id" json:"charge_station_id"`
	TokenUid        string           `db:"token_uid" json:"token_uid"`
	TokenType       string           `db:"token_type" json:"token_type"`
	MeterStart      int32            `db:"meter_start" json:"meter_start"`
	StartTimestamp  pgtype.Timestamp `db:"start_timestamp" json:"start_timestamp"`
	Offline         bool             `db:"offline" json:"offline"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, CreateTransaction,
		arg.ID,
		arg.ChargeStationID,
		arg.TokenUid,
		arg.TokenType,
		arg.MeterStart,
		arg.StartTimestamp,
		arg.Offline,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ChargeStationID,
		&i.TokenUid,
		&i.TokenType,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.StoppedReason,
		&i.UpdatedSeqNo,
		&i.Offline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCost,
	)
	return i, err
}

const FindActiveTransaction = `-- name: FindActiveTransaction :one
SELECT id, charge_station_id, token_uid, token_type, meter_start, meter_stop, start_timestamp, stop_timestamp, stopped_reason, updated_seq_no, offline, created_at, updated_at, last_cost FROM transactions 
WHERE charge_station_id = $1 AND stop_timestamp IS NULL
ORDER BY start_timestamp DESC
LIMIT 1
`

func (q *Queries) FindActiveTransaction(ctx context.Context, chargeStationID string) (Transaction, error) {
	row := q.db.QueryRow(ctx, FindActiveTransaction, chargeStationID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ChargeStationID,
		&i.TokenUid,
		&i.TokenType,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.StoppedReason,
		&i.UpdatedSeqNo,
		&i.Offline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCost,
	)
	return i, err
}

const GetMeterValues = `-- name: GetMeterValues :many
SELECT id, transaction_id, timestamp, sampled_values, created_at FROM transaction_meter_values
WHERE transaction_id = $1
ORDER BY timestamp ASC
`

func (q *Queries) GetMeterValues(ctx context.Context, transactionID string) ([]TransactionMeterValue, error) {
	rows, err := q.db.Query(ctx, GetMeterValues, transactionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []TransactionMeterValue{}
	for rows.Next() {
		var i TransactionMeterValue
		if err := rows.Scan(
			&i.ID,
			&i.TransactionID,
			&i.Timestamp,
			&i.SampledValues,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const GetTransaction = `-- name: GetTransaction :one
SELECT id, charge_station_id, token_uid, token_type, meter_start, meter_stop, start_timestamp, stop_timestamp, stopped_reason, updated_seq_no, offline, created_at, updated_at, last_cost FROM transactions WHERE id = $1
`

func (q *Queries) GetTransaction(ctx context.Context, id string) (Transaction, error) {
	row := q.db.QueryRow(ctx, GetTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ChargeStationID,
		&i.TokenUid,
		&i.TokenType,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.StoppedReason,
		&i.UpdatedSeqNo,
		&i.Offline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCost,
	)
	return i, err
}

const ListTransactions = `-- name: ListTransactions :many
SELECT id, charge_station_id, token_uid, token_type, meter_start, meter_stop, start_timestamp, stop_timestamp, stopped_reason, updated_seq_no, offline, created_at, updated_at, last_cost FROM transactions
ORDER BY start_timestamp DESC
`

func (q *Queries) ListTransactions(ctx context.Context) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, ListTransactions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.ChargeStationID,
			&i.TokenUid,
			&i.TokenType,
			&i.MeterStart,
			&i.MeterStop,
			&i.StartTimestamp,
			&i.StopTimestamp,
			&i.StoppedReason,
			&i.UpdatedSeqNo,
			&i.Offline,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.LastCost,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpdateTransaction = `-- name: UpdateTransaction :one
UPDATE transactions
SET meter_stop = $2,
    stop_timestamp = $3,
    stopped_reason = $4,
    updated_seq_no = $5,
    updated_at = NOW()
WHERE id = $1
RETURNING id, charge_station_id, token_uid, token_type, meter_start, meter_stop, start_timestamp, stop_timestamp, stopped_reason, updated_seq_no, offline, created_at, updated_at, last_cost
`

type UpdateTransactionParams struct {
	ID            string           `db:"id" json:"id"`
	MeterStop     pgtype.Int4      `db:"meter_stop" json:"meter_stop"`
	StopTimestamp pgtype.Timestamp `db:"stop_timestamp" json:"stop_timestamp"`
	StoppedReason pgtype.Text      `db:"stopped_reason" json:"stopped_reason"`
	UpdatedSeqNo  int32            `db:"updated_seq_no" json:"updated_seq_no"`
}

func (q *Queries) UpdateTransaction(ctx context.Context, arg UpdateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, UpdateTransaction,
		arg.ID,
		arg.MeterStop,
		arg.StopTimestamp,
		arg.StoppedReason,
		arg.UpdatedSeqNo,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.ChargeStationID,
		&i.TokenUid,
		&i.TokenType,
		&i.MeterStart,
		&i.MeterStop,
		&i.StartTimestamp,
		&i.StopTimestamp,
		&i.StoppedReason,
		&i.UpdatedSeqNo,
		&i.Offline,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.LastCost,
	)
	return i, err
}
