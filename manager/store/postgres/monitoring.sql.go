// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: monitoring.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const CountChargeStationEvents = `-- name: CountChargeStationEvents :one
SELECT COUNT(*) FROM charge_station_event
WHERE charge_station_id = $1
`

func (q *Queries) CountChargeStationEvents(ctx context.Context, chargeStationID string) (int64, error) {
	row := q.db.QueryRow(ctx, CountChargeStationEvents, chargeStationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const CountDeviceReports = `-- name: CountDeviceReports :one
SELECT COUNT(*) FROM device_report
WHERE charge_station_id = $1
`

func (q *Queries) CountDeviceReports(ctx context.Context, chargeStationID string) (int64, error) {
	row := q.db.QueryRow(ctx, CountDeviceReports, chargeStationID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const DeleteVariableMonitoring = `-- name: DeleteVariableMonitoring :exec
DELETE FROM variable_monitoring
WHERE charge_station_id = $1 AND id = $2
`

type DeleteVariableMonitoringParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	ID              int32  `db:"id" json:"id"`
}

func (q *Queries) DeleteVariableMonitoring(ctx context.Context, arg DeleteVariableMonitoringParams) error {
	_, err := q.db.Exec(ctx, DeleteVariableMonitoring, arg.ChargeStationID, arg.ID)
	return err
}

const GetVariableMonitoring = `-- name: GetVariableMonitoring :one
SELECT id, charge_station_id, component_name, component_instance, variable_name, variable_instance,
       monitor_type, value, severity, transaction, created_at
FROM variable_monitoring
WHERE charge_station_id = $1 AND id = $2
`

type GetVariableMonitoringParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	ID              int32  `db:"id" json:"id"`
}

func (q *Queries) GetVariableMonitoring(ctx context.Context, arg GetVariableMonitoringParams) (VariableMonitoring, error) {
	row := q.db.QueryRow(ctx, GetVariableMonitoring, arg.ChargeStationID, arg.ID)
	var i VariableMonitoring
	err := row.Scan(
		&i.ID,
		&i.ChargeStationID,
		&i.ComponentName,
		&i.ComponentInstance,
		&i.VariableName,
		&i.VariableInstance,
		&i.MonitorType,
		&i.Value,
		&i.Severity,
		&i.Transaction,
		&i.CreatedAt,
	)
	return i, err
}

const InsertChargeStationEvent = `-- name: InsertChargeStationEvent :one
INSERT INTO charge_station_event (
    charge_station_id,
    timestamp,
    event_type,
    tech_code,
    tech_info,
    event_data,
    component_id,
    variable_id,
    cleared,
    created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
RETURNING id
`

type InsertChargeStationEventParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	Timestamp       pgtype.Timestamptz `db:"timestamp" json:"timestamp"`
	EventType       string             `db:"event_type" json:"event_type"`
	TechCode        pgtype.Text        `db:"tech_code" json:"tech_code"`
	TechInfo        pgtype.Text        `db:"tech_info" json:"tech_info"`
	EventData       pgtype.Text        `db:"event_data" json:"event_data"`
	ComponentID     pgtype.Text        `db:"component_id" json:"component_id"`
	VariableID      pgtype.Text        `db:"variable_id" json:"variable_id"`
	Cleared         bool               `db:"cleared" json:"cleared"`
}

func (q *Queries) InsertChargeStationEvent(ctx context.Context, arg InsertChargeStationEventParams) (int32, error) {
	row := q.db.QueryRow(ctx, InsertChargeStationEvent,
		arg.ChargeStationID,
		arg.Timestamp,
		arg.EventType,
		arg.TechCode,
		arg.TechInfo,
		arg.EventData,
		arg.ComponentID,
		arg.VariableID,
		arg.Cleared,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const InsertDeviceReport = `-- name: InsertDeviceReport :one
INSERT INTO device_report (
    charge_station_id,
    request_id,
    generated_at,
    report_type,
    report_data,
    created_at
)
VALUES ($1, $2, $3, $4, $5, NOW())
RETURNING id
`

type InsertDeviceReportParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	RequestID       int32              `db:"request_id" json:"request_id"`
	GeneratedAt     pgtype.Timestamptz `db:"generated_at" json:"generated_at"`
	ReportType      pgtype.Text        `db:"report_type" json:"report_type"`
	ReportData      []byte             `db:"report_data" json:"report_data"`
}

func (q *Queries) InsertDeviceReport(ctx context.Context, arg InsertDeviceReportParams) (int32, error) {
	row := q.db.QueryRow(ctx, InsertDeviceReport,
		arg.ChargeStationID,
		arg.RequestID,
		arg.GeneratedAt,
		arg.ReportType,
		arg.ReportData,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const ListChargeStationEvents = `-- name: ListChargeStationEvents :many
SELECT id, charge_station_id, timestamp, event_type, tech_code, tech_info,
       event_data, component_id, variable_id, cleared, created_at
FROM charge_station_event
WHERE charge_station_id = $1
ORDER BY timestamp DESC
LIMIT $2 OFFSET $3
`

type ListChargeStationEventsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
	Offset          int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListChargeStationEvents(ctx context.Context, arg ListChargeStationEventsParams) ([]ChargeStationEvent, error) {
	rows, err := q.db.Query(ctx, ListChargeStationEvents, arg.ChargeStationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []ChargeStationEvent{}
	for rows.Next() {
		var i ChargeStationEvent
		if err := rows.Scan(
			&i.ID,
			&i.ChargeStationID,
			&i.Timestamp,
			&i.EventType,
			&i.TechCode,
			&i.TechInfo,
			&i.EventData,
			&i.ComponentID,
			&i.VariableID,
			&i.Cleared,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListDeviceReports = `-- name: ListDeviceReports :many
SELECT id, charge_station_id, request_id, generated_at, report_type, report_data, created_at
FROM device_report
WHERE charge_station_id = $1
ORDER BY generated_at DESC
LIMIT $2 OFFSET $3
`

type ListDeviceReportsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
	Offset          int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListDeviceReports(ctx context.Context, arg ListDeviceReportsParams) ([]DeviceReport, error) {
	rows, err := q.db.Query(ctx, ListDeviceReports, arg.ChargeStationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DeviceReport{}
	for rows.Next() {
		var i DeviceReport
		if err := rows.Scan(
			&i.ID,
			&i.ChargeStationID,
			&i.RequestID,
			&i.GeneratedAt,
			&i.ReportType,
			&i.ReportData,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListVariableMonitoring = `-- name: ListVariableMonitoring :many
SELECT id, charge_station_id, component_name, component_instance, variable_name, variable_instance,
       monitor_type, value, severity, transaction, created_at
FROM variable_monitoring
WHERE charge_station_id = $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type ListVariableMonitoringParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
	Offset          int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListVariableMonitoring(ctx context.Context, arg ListVariableMonitoringParams) ([]VariableMonitoring, error) {
	rows, err := q.db.Query(ctx, ListVariableMonitoring, arg.ChargeStationID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []VariableMonitoring{}
	for rows.Next() {
		var i VariableMonitoring
		if err := rows.Scan(
			&i.ID,
			&i.ChargeStationID,
			&i.ComponentName,
			&i.ComponentInstance,
			&i.VariableName,
			&i.VariableInstance,
			&i.MonitorType,
			&i.Value,
			&i.Severity,
			&i.Transaction,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertVariableMonitoring = `-- name: UpsertVariableMonitoring :one
INSERT INTO variable_monitoring (
    charge_station_id,
    component_name,
    component_instance,
    variable_name,
    variable_instance,
    monitor_type,
    value,
    severity,
    transaction,
    created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, NOW())
ON CONFLICT (id) DO UPDATE SET
    component_name = EXCLUDED.component_name,
    component_instance = EXCLUDED.component_instance,
    variable_name = EXCLUDED.variable_name,
    variable_instance = EXCLUDED.variable_instance,
    monitor_type = EXCLUDED.monitor_type,
    value = EXCLUDED.value,
    severity = EXCLUDED.severity,
    transaction = EXCLUDED.transaction
RETURNING id
`

type UpsertVariableMonitoringParams struct {
	ChargeStationID   string      `db:"charge_station_id" json:"charge_station_id"`
	ComponentName     string      `db:"component_name" json:"component_name"`
	ComponentInstance pgtype.Text `db:"component_instance" json:"component_instance"`
	VariableName      string      `db:"variable_name" json:"variable_name"`
	VariableInstance  pgtype.Text `db:"variable_instance" json:"variable_instance"`
	MonitorType       string      `db:"monitor_type" json:"monitor_type"`
	Value             float64     `db:"value" json:"value"`
	Severity          int32       `db:"severity" json:"severity"`
	Transaction       bool        `db:"transaction" json:"transaction"`
}

func (q *Queries) UpsertVariableMonitoring(ctx context.Context, arg UpsertVariableMonitoringParams) (int32, error) {
	row := q.db.QueryRow(ctx, UpsertVariableMonitoring,
		arg.ChargeStationID,
		arg.ComponentName,
		arg.ComponentInstance,
		arg.VariableName,
		arg.VariableInstance,
		arg.MonitorType,
		arg.Value,
		arg.Severity,
		arg.Transaction,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const UpsertVariableMonitoringWithId = `-- name: UpsertVariableMonitoringWithId :exec
INSERT INTO variable_monitoring (
    id,
    charge_station_id,
    component_name,
    component_instance,
    variable_name,
    variable_instance,
    monitor_type,
    value,
    severity,
    transaction,
    created_at
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW())
ON CONFLICT (id) DO UPDATE SET
    component_name = EXCLUDED.component_name,
    component_instance = EXCLUDED.component_instance,
    variable_name = EXCLUDED.variable_name,
    variable_instance = EXCLUDED.variable_instance,
    monitor_type = EXCLUDED.monitor_type,
    value = EXCLUDED.value,
    severity = EXCLUDED.severity,
    transaction = EXCLUDED.transaction
`

type UpsertVariableMonitoringWithIdParams struct {
	ID                int32       `db:"id" json:"id"`
	ChargeStationID   string      `db:"charge_station_id" json:"charge_station_id"`
	ComponentName     string      `db:"component_name" json:"component_name"`
	ComponentInstance pgtype.Text `db:"component_instance" json:"component_instance"`
	VariableName      string      `db:"variable_name" json:"variable_name"`
	VariableInstance  pgtype.Text `db:"variable_instance" json:"variable_instance"`
	MonitorType       string      `db:"monitor_type" json:"monitor_type"`
	Value             float64     `db:"value" json:"value"`
	Severity          int32       `db:"severity" json:"severity"`
	Transaction       bool        `db:"transaction" json:"transaction"`
}

func (q *Queries) UpsertVariableMonitoringWithId(ctx context.Context, arg UpsertVariableMonitoringWithIdParams) error {
	_, err := q.db.Exec(ctx, UpsertVariableMonitoringWithId,
		arg.ID,
		arg.ChargeStationID,
		arg.ComponentName,
		arg.ComponentInstance,
		arg.VariableName,
		arg.VariableInstance,
		arg.MonitorType,
		arg.Value,
		arg.Severity,
		arg.Transaction,
	)
	return err
}
