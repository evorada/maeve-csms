// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: remote_transactions.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const DeleteRemoteStartTransactionRequest = `-- name: DeleteRemoteStartTransactionRequest :exec
DELETE FROM remote_start_transaction_requests WHERE charge_station_id = $1
`

func (q *Queries) DeleteRemoteStartTransactionRequest(ctx context.Context, chargeStationID string) error {
	_, err := q.db.Exec(ctx, DeleteRemoteStartTransactionRequest, chargeStationID)
	return err
}

const DeleteRemoteStopTransactionRequest = `-- name: DeleteRemoteStopTransactionRequest :exec
DELETE FROM remote_stop_transaction_requests WHERE charge_station_id = $1
`

func (q *Queries) DeleteRemoteStopTransactionRequest(ctx context.Context, chargeStationID string) error {
	_, err := q.db.Exec(ctx, DeleteRemoteStopTransactionRequest, chargeStationID)
	return err
}

const GetRemoteStartTransactionRequest = `-- name: GetRemoteStartTransactionRequest :one
SELECT charge_station_id, id_tag, connector_id, charging_profile, status, send_after, request_type, created_at FROM remote_start_transaction_requests WHERE charge_station_id = $1
`

func (q *Queries) GetRemoteStartTransactionRequest(ctx context.Context, chargeStationID string) (RemoteStartTransactionRequest, error) {
	row := q.db.QueryRow(ctx, GetRemoteStartTransactionRequest, chargeStationID)
	var i RemoteStartTransactionRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.IDTag,
		&i.ConnectorID,
		&i.ChargingProfile,
		&i.Status,
		&i.SendAfter,
		&i.RequestType,
		&i.CreatedAt,
	)
	return i, err
}

const GetRemoteStopTransactionRequest = `-- name: GetRemoteStopTransactionRequest :one
SELECT charge_station_id, transaction_id, status, send_after, request_type, created_at FROM remote_stop_transaction_requests WHERE charge_station_id = $1
`

func (q *Queries) GetRemoteStopTransactionRequest(ctx context.Context, chargeStationID string) (RemoteStopTransactionRequest, error) {
	row := q.db.QueryRow(ctx, GetRemoteStopTransactionRequest, chargeStationID)
	var i RemoteStopTransactionRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.TransactionID,
		&i.Status,
		&i.SendAfter,
		&i.RequestType,
		&i.CreatedAt,
	)
	return i, err
}

const ListRemoteStartTransactionRequests = `-- name: ListRemoteStartTransactionRequests :many
SELECT charge_station_id, id_tag, connector_id, charging_profile, status, send_after, request_type, created_at FROM remote_start_transaction_requests
WHERE charge_station_id > $1
ORDER BY charge_station_id ASC
LIMIT $2
`

type ListRemoteStartTransactionRequestsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListRemoteStartTransactionRequests(ctx context.Context, arg ListRemoteStartTransactionRequestsParams) ([]RemoteStartTransactionRequest, error) {
	rows, err := q.db.Query(ctx, ListRemoteStartTransactionRequests, arg.ChargeStationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RemoteStartTransactionRequest{}
	for rows.Next() {
		var i RemoteStartTransactionRequest
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.IDTag,
			&i.ConnectorID,
			&i.ChargingProfile,
			&i.Status,
			&i.SendAfter,
			&i.RequestType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListRemoteStopTransactionRequests = `-- name: ListRemoteStopTransactionRequests :many
SELECT charge_station_id, transaction_id, status, send_after, request_type, created_at FROM remote_stop_transaction_requests
WHERE charge_station_id > $1
ORDER BY charge_station_id ASC
LIMIT $2
`

type ListRemoteStopTransactionRequestsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListRemoteStopTransactionRequests(ctx context.Context, arg ListRemoteStopTransactionRequestsParams) ([]RemoteStopTransactionRequest, error) {
	rows, err := q.db.Query(ctx, ListRemoteStopTransactionRequests, arg.ChargeStationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []RemoteStopTransactionRequest{}
	for rows.Next() {
		var i RemoteStopTransactionRequest
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.TransactionID,
			&i.Status,
			&i.SendAfter,
			&i.RequestType,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const SetRemoteStartTransactionRequest = `-- name: SetRemoteStartTransactionRequest :one
INSERT INTO remote_start_transaction_requests (charge_station_id, id_tag, connector_id, charging_profile, status, send_after, request_type)
VALUES ($1, $2, $3, $4, $5, $6, $7)
ON CONFLICT (charge_station_id) DO UPDATE SET
    id_tag = EXCLUDED.id_tag,
    connector_id = EXCLUDED.connector_id,
    charging_profile = EXCLUDED.charging_profile,
    status = EXCLUDED.status,
    send_after = EXCLUDED.send_after,
    request_type = EXCLUDED.request_type
RETURNING charge_station_id, id_tag, connector_id, charging_profile, status, send_after, request_type, created_at
`

type SetRemoteStartTransactionRequestParams struct {
	ChargeStationID string           `db:"charge_station_id" json:"charge_station_id"`
	IDTag           string           `db:"id_tag" json:"id_tag"`
	ConnectorID     pgtype.Int4      `db:"connector_id" json:"connector_id"`
	ChargingProfile pgtype.Text      `db:"charging_profile" json:"charging_profile"`
	Status          string           `db:"status" json:"status"`
	SendAfter       pgtype.Timestamp `db:"send_after" json:"send_after"`
	RequestType     string           `db:"request_type" json:"request_type"`
}

func (q *Queries) SetRemoteStartTransactionRequest(ctx context.Context, arg SetRemoteStartTransactionRequestParams) (RemoteStartTransactionRequest, error) {
	row := q.db.QueryRow(ctx, SetRemoteStartTransactionRequest,
		arg.ChargeStationID,
		arg.IDTag,
		arg.ConnectorID,
		arg.ChargingProfile,
		arg.Status,
		arg.SendAfter,
		arg.RequestType,
	)
	var i RemoteStartTransactionRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.IDTag,
		&i.ConnectorID,
		&i.ChargingProfile,
		&i.Status,
		&i.SendAfter,
		&i.RequestType,
		&i.CreatedAt,
	)
	return i, err
}

const SetRemoteStopTransactionRequest = `-- name: SetRemoteStopTransactionRequest :one
INSERT INTO remote_stop_transaction_requests (charge_station_id, transaction_id, status, send_after, request_type)
VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (charge_station_id) DO UPDATE SET
    transaction_id = EXCLUDED.transaction_id,
    status = EXCLUDED.status,
    send_after = EXCLUDED.send_after,
    request_type = EXCLUDED.request_type
RETURNING charge_station_id, transaction_id, status, send_after, request_type, created_at
`

type SetRemoteStopTransactionRequestParams struct {
	ChargeStationID string           `db:"charge_station_id" json:"charge_station_id"`
	TransactionID   string           `db:"transaction_id" json:"transaction_id"`
	Status          string           `db:"status" json:"status"`
	SendAfter       pgtype.Timestamp `db:"send_after" json:"send_after"`
	RequestType     string           `db:"request_type" json:"request_type"`
}

func (q *Queries) SetRemoteStopTransactionRequest(ctx context.Context, arg SetRemoteStopTransactionRequestParams) (RemoteStopTransactionRequest, error) {
	row := q.db.QueryRow(ctx, SetRemoteStopTransactionRequest,
		arg.ChargeStationID,
		arg.TransactionID,
		arg.Status,
		arg.SendAfter,
		arg.RequestType,
	)
	var i RemoteStopTransactionRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.TransactionID,
		&i.Status,
		&i.SendAfter,
		&i.RequestType,
		&i.CreatedAt,
	)
	return i, err
}
