// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: diagnostics.sql

package postgres

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const DeleteDiagnosticsRequest = `-- name: DeleteDiagnosticsRequest :exec
DELETE FROM diagnostics_request
WHERE charge_station_id = $1
`

func (q *Queries) DeleteDiagnosticsRequest(ctx context.Context, chargeStationID string) error {
	_, err := q.db.Exec(ctx, DeleteDiagnosticsRequest, chargeStationID)
	return err
}

const DeleteLogRequest = `-- name: DeleteLogRequest :exec
DELETE FROM log_request
WHERE charge_station_id = $1
`

func (q *Queries) DeleteLogRequest(ctx context.Context, chargeStationID string) error {
	_, err := q.db.Exec(ctx, DeleteLogRequest, chargeStationID)
	return err
}

const GetDiagnosticsRequest = `-- name: GetDiagnosticsRequest :one
SELECT charge_station_id, location, start_time, stop_time, retries, retry_interval, status, send_after
FROM diagnostics_request
WHERE charge_station_id = $1
`

func (q *Queries) GetDiagnosticsRequest(ctx context.Context, chargeStationID string) (DiagnosticsRequest, error) {
	row := q.db.QueryRow(ctx, GetDiagnosticsRequest, chargeStationID)
	var i DiagnosticsRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.Location,
		&i.StartTime,
		&i.StopTime,
		&i.Retries,
		&i.RetryInterval,
		&i.Status,
		&i.SendAfter,
	)
	return i, err
}

const GetLogRequest = `-- name: GetLogRequest :one
SELECT charge_station_id, log_type, request_id, remote_location, oldest_timestamp, latest_timestamp, retries, retry_interval, status, send_after
FROM log_request
WHERE charge_station_id = $1
`

func (q *Queries) GetLogRequest(ctx context.Context, chargeStationID string) (LogRequest, error) {
	row := q.db.QueryRow(ctx, GetLogRequest, chargeStationID)
	var i LogRequest
	err := row.Scan(
		&i.ChargeStationID,
		&i.LogType,
		&i.RequestID,
		&i.RemoteLocation,
		&i.OldestTimestamp,
		&i.LatestTimestamp,
		&i.Retries,
		&i.RetryInterval,
		&i.Status,
		&i.SendAfter,
	)
	return i, err
}

const ListDiagnosticsRequests = `-- name: ListDiagnosticsRequests :many
SELECT charge_station_id, location, start_time, stop_time, retries, retry_interval, status, send_after
FROM diagnostics_request
WHERE charge_station_id > $1
ORDER BY charge_station_id
LIMIT $2
`

type ListDiagnosticsRequestsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListDiagnosticsRequests(ctx context.Context, arg ListDiagnosticsRequestsParams) ([]DiagnosticsRequest, error) {
	rows, err := q.db.Query(ctx, ListDiagnosticsRequests, arg.ChargeStationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []DiagnosticsRequest{}
	for rows.Next() {
		var i DiagnosticsRequest
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.Location,
			&i.StartTime,
			&i.StopTime,
			&i.Retries,
			&i.RetryInterval,
			&i.Status,
			&i.SendAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const ListLogRequests = `-- name: ListLogRequests :many
SELECT charge_station_id, log_type, request_id, remote_location, oldest_timestamp, latest_timestamp, retries, retry_interval, status, send_after
FROM log_request
WHERE charge_station_id > $1
ORDER BY charge_station_id
LIMIT $2
`

type ListLogRequestsParams struct {
	ChargeStationID string `db:"charge_station_id" json:"charge_station_id"`
	Limit           int32  `db:"limit" json:"limit"`
}

func (q *Queries) ListLogRequests(ctx context.Context, arg ListLogRequestsParams) ([]LogRequest, error) {
	rows, err := q.db.Query(ctx, ListLogRequests, arg.ChargeStationID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []LogRequest{}
	for rows.Next() {
		var i LogRequest
		if err := rows.Scan(
			&i.ChargeStationID,
			&i.LogType,
			&i.RequestID,
			&i.RemoteLocation,
			&i.OldestTimestamp,
			&i.LatestTimestamp,
			&i.Retries,
			&i.RetryInterval,
			&i.Status,
			&i.SendAfter,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const UpsertDiagnosticsRequest = `-- name: UpsertDiagnosticsRequest :exec
INSERT INTO diagnostics_request (
    charge_station_id,
    location,
    start_time,
    stop_time,
    retries,
    retry_interval,
    status,
    send_after
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (charge_station_id) DO UPDATE SET
    location = EXCLUDED.location,
    start_time = EXCLUDED.start_time,
    stop_time = EXCLUDED.stop_time,
    retries = EXCLUDED.retries,
    retry_interval = EXCLUDED.retry_interval,
    status = EXCLUDED.status,
    send_after = EXCLUDED.send_after
`

type UpsertDiagnosticsRequestParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	Location        string             `db:"location" json:"location"`
	StartTime       pgtype.Timestamptz `db:"start_time" json:"start_time"`
	StopTime        pgtype.Timestamptz `db:"stop_time" json:"stop_time"`
	Retries         pgtype.Int4        `db:"retries" json:"retries"`
	RetryInterval   pgtype.Int4        `db:"retry_interval" json:"retry_interval"`
	Status          string             `db:"status" json:"status"`
	SendAfter       pgtype.Timestamptz `db:"send_after" json:"send_after"`
}

func (q *Queries) UpsertDiagnosticsRequest(ctx context.Context, arg UpsertDiagnosticsRequestParams) error {
	_, err := q.db.Exec(ctx, UpsertDiagnosticsRequest,
		arg.ChargeStationID,
		arg.Location,
		arg.StartTime,
		arg.StopTime,
		arg.Retries,
		arg.RetryInterval,
		arg.Status,
		arg.SendAfter,
	)
	return err
}

const UpsertLogRequest = `-- name: UpsertLogRequest :exec
INSERT INTO log_request (
    charge_station_id,
    log_type,
    request_id,
    remote_location,
    oldest_timestamp,
    latest_timestamp,
    retries,
    retry_interval,
    status,
    send_after
)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
ON CONFLICT (charge_station_id) DO UPDATE SET
    log_type = EXCLUDED.log_type,
    request_id = EXCLUDED.request_id,
    remote_location = EXCLUDED.remote_location,
    oldest_timestamp = EXCLUDED.oldest_timestamp,
    latest_timestamp = EXCLUDED.latest_timestamp,
    retries = EXCLUDED.retries,
    retry_interval = EXCLUDED.retry_interval,
    status = EXCLUDED.status,
    send_after = EXCLUDED.send_after
`

type UpsertLogRequestParams struct {
	ChargeStationID string             `db:"charge_station_id" json:"charge_station_id"`
	LogType         string             `db:"log_type" json:"log_type"`
	RequestID       int32              `db:"request_id" json:"request_id"`
	RemoteLocation  string             `db:"remote_location" json:"remote_location"`
	OldestTimestamp pgtype.Timestamptz `db:"oldest_timestamp" json:"oldest_timestamp"`
	LatestTimestamp pgtype.Timestamptz `db:"latest_timestamp" json:"latest_timestamp"`
	Retries         pgtype.Int4        `db:"retries" json:"retries"`
	RetryInterval   pgtype.Int4        `db:"retry_interval" json:"retry_interval"`
	Status          string             `db:"status" json:"status"`
	SendAfter       pgtype.Timestamptz `db:"send_after" json:"send_after"`
}

func (q *Queries) UpsertLogRequest(ctx context.Context, arg UpsertLogRequestParams) error {
	_, err := q.db.Exec(ctx, UpsertLogRequest,
		arg.ChargeStationID,
		arg.LogType,
		arg.RequestID,
		arg.RemoteLocation,
		arg.OldestTimestamp,
		arg.LatestTimestamp,
		arg.Retries,
		arg.RetryInterval,
		arg.Status,
		arg.SendAfter,
	)
	return err
}
